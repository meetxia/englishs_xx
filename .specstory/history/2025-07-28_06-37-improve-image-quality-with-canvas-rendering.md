<!-- Generated by SpecStory -->

# Improve image quality with canvas rendering (2025-07-28 14:37:52)

_**User**_

@index.html 现在卡片生成后，点击下载出来的图片一点都不好！@单词列表.png @爽文带背 (2).png @填空测试.png @中英对照 (1).png ,看看排版一点都不美观和高级，
请你帮我实现以下方案技术栈： 原生Canvas 2D API + 自定义渲染引擎
原理： 直接使用Canvas API绘制，避免DOM渲染和截图转换的质量损失
以下是代码示例@canvas-renderer.js ，请跟具我的项目修改！@index.html 

---

_**Assistant**_



---

I'll implement a proper Canvas-based rendering system for your vocabulary cards, replacing the html2canvas approach which is causing quality issues.

---

```diff
      <!-- Tone.js已禁用以避免兼容性问题 -->
      <link rel="stylesheet" href="css/styles.css">
+     <script src="js/canvas-renderer.js"></script>
      <style>
          .sticky-generate-btn {
                                  <p id="story-output" class="text-gray-700 leading-relaxed text-base"></p>
                              </div>
-                             <button onclick="downloadCard('card1-content', '爽文带背.png')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
+                             <button onclick="downloadCard('card1-content', '爽文带背.png', 'story')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
                          </div>
                      </div>
                                  <p id="study-output" class="text-gray-700 leading-relaxed text-base"></p>
                              </div>
-                             <button onclick="downloadCard('card2-content', '中英对照.png')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
+                             <button onclick="downloadCard('card2-content', '中英对照.png', 'bilingual')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
                          </div>
                      </div>
                                  <div id="vocab-output" class="space-y-4"></div>
                              </div>
-                             <button onclick="downloadCard('card3-content', '单词列表.png')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
+                             <button onclick="downloadCard('card3-content', '单词列表.png', 'vocab')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
                          </div>
                      </div>
                                  <div id="test-output" class="text-gray-700 leading-relaxed text-base"></div>
                              </div>
-                             <button onclick="downloadCard('card4-content', '填空测试.png')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
+                             <button onclick="downloadCard('card4-content', '填空测试.png', 'test')" class="mt-4 w-full bg-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors">下载图片</button>
                          </div>
                      </div>
```

---

Now I'll update the main.js file to implement the new downloadCard function that uses our canvas renderer:

---

<details>
            <summary>Searched codebase "main.js" • **2** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |

</details>

---

<details>
            <summary>Grep search for "function downloadCard" • **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///h%3A/momo-ruanjiansheji/englishs_xx/public/js/main.js` | L1039 | `function downloadCard(elementId, filename) {` |
| `file:///h%3A/momo-ruanjiansheji/englishs_xx/.specstory/history/2025-07-27_10-03-%E5%88%86%E7%A6%BBcss%E5%92%8Cjs%E6%96%87%E4%BB%B6.md` | L355 | `+ function downloadCard(elementId, filename) {` |
| `file:///h%3A/momo-ruanjiansheji/englishs_xx/.specstory/history/2025-07-27_10-03-%E5%88%86%E7%A6%BBcss%E5%92%8Cjs%E6%96%87%E4%BB%B6.md` | L683 | `-         function downloadCard(elementId, filename) {` |
| `file:///h%3A/momo-ruanjiansheji/englishs_xx/public/js/main.js` | L1039 | `function downloadCard(elementId, filename) {` |

</details>

---

Read file: public/js/main.js

---

Now I'll update the main.js file with our new downloadCard function:

---



---

Now I'll enhance the CanvasCardRenderer class to better handle different card types and ensure high-quality output:

---

Cancelled

---



---

_**User**_

请继续编辑

---

_**Assistant**_



---

Now I'll enhance the CanvasCardRenderer class to make it work perfectly with all card types:

---

```diff
          this.width = width;
          this.height = height;
+         
+         // 预加载字体
+         this.fontLoaded = false;
+         this.loadFonts();
+     }
+ 
+     async loadFonts() {
+         // 加载字体
+         const fontFace = new FontFace(
+             'NotoSansSC', 
+             'url(https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap)'
+         );
+         
+         try {
+             await fontFace.load();
+             document.fonts.add(fontFace);
+             this.fontLoaded = true;
+             console.log('字体加载成功');
+         } catch (error) {
+             console.warn('字体加载失败，使用系统字体', error);
+         }
      }
  
      async renderStoryCard(story, words, mode) {
          // 清空画布
          this.ctx.clearRect(0, 0, this.width, this.height);
+         
+         // 根据模式选择背景颜色和标题颜色
+         const themeColors = {
+             'story': { bg: ['#f8f0fc', '#e9d8fd'], title: '#9061f9' },    // 紫色渐变
+             'bilingual': { bg: ['#e1f5fe', '#b3e5fc'], title: '#0288d1' }, // 蓝色渐变
+             'vocab': { bg: ['#e8f5e9', '#c8e6c9'], title: '#43a047' },     // 绿色渐变
+             'test': { bg: ['#fff8e1', '#ffecb3'], title: '#ff8f00' }       // 黄色渐变
+         };
+         
+         const colorTheme = themeColors[mode] || themeColors.story;
          
          // 绘制背景渐变
          const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
-         gradient.addColorStop(0, '#667eea');
-         gradient.addColorStop(1, '#764ba2');
+         gradient.addColorStop(0, colorTheme.bg[0]);
+         gradient.addColorStop(1, colorTheme.bg[1]);
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.width, this.height);
          
-         // 绘制装饰边框
+         // 绘制装饰边框和纹理
          this.drawDecorativeBorder();
+         this.drawPatternBackground();
          
          // 绘制标题
-         await this.drawTitle(mode);
+         await this.drawTitle(mode, colorTheme.title);
+         
+         // 计算内容区域
+         const contentArea = {
+             x: 80,
+             y: 200,
+             width: this.width - 160,
+             height: this.height - 280
+         };
          
          // 绘制内容
-         if (mode === 'story') {
-             await this.drawStoryContent(story, words);
-         } else if (mode === 'vocab') {
-             await this.drawVocabList(words);
-         } else if (mode === 'test') {
-             await this.drawTestContent(story, words);
+         switch(mode) {
+             case 'story':
+                 await this.drawStoryContent(story, words, contentArea);
+                 break;
+             case 'bilingual':
+                 await this.drawBilingualContent(story, words, contentArea);
+                 break;
+             case 'vocab':
+                 await this.drawVocabList(words, contentArea);
+                 break;
+             case 'test':
+                 await this.drawTestContent(story, words, contentArea);
+                 break;
+             default:
+                 await this.drawStoryContent(story, words, contentArea);
          }
+         
+         // 绘制页脚
+         this.drawFooter();
          
          return this.canvas.toDataURL('image/png', 1.0);
      }
+ 
+     drawPatternBackground() {
+         // 绘制微妙的背景纹理
+         this.ctx.save();
+         this.ctx.globalAlpha = 0.03;
+         
+         for (let x = 0; x < this.width; x += 20) {
+             for (let y = 0; y < this.height; y += 20) {
+                 if (Math.random() > 0.8) {
+                     this.ctx.fillStyle = '#000';
+                     this.ctx.fillRect(x, y, 1, 1);
+                 }
+             }
+         }
+         
+         this.ctx.restore();
+     }
  
      drawDecorativeBorder() {
          // 外边框
-         this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
-         this.ctx.lineWidth = 4;
-         this.ctx.strokeRect(20, 20, this.width - 40, this.height - 40);
+         this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
+         this.ctx.lineWidth = 1;
+         this.ctx.strokeRect(40, 40, this.width - 80, this.height - 80);
          
          // 内边框
-         this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
-         this.ctx.lineWidth = 2;
-         this.ctx.strokeRect(40, 40, this.width - 80, this.height - 80);
+         this.ctx.strokeStyle = 'rgba(0,0,0,0.05)';
+         this.ctx.lineWidth = 1;
+         this.ctx.strokeRect(60, 60, this.width - 120, this.height - 120);
          
          // 装饰角
      drawCornerDecorations() {
          const corners = [
-             {x: 60, y: 60}, {x: this.width - 60, y: 60},
-             {x: 60, y: this.height - 60}, {x: this.width - 60, y: this.height - 60}
+             {x: 40, y: 40}, {x: this.width - 40, y: 40},
+             {x: 40, y: this.height - 40}, {x: this.width - 40, y: this.height - 40}
          ];
          
-         this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
+         this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
          corners.forEach(corner => {
+             // 绘制优雅的角装饰
              this.ctx.beginPath();
-             this.ctx.arc(corner.x, corner.y, 8, 0, Math.PI * 2);
-             this.ctx.fill();
+             this.ctx.moveTo(corner.x, corner.y);
+             this.ctx.lineTo(corner.x + 30, corner.y);
+             this.ctx.moveTo(corner.x, corner.y);
+             this.ctx.lineTo(corner.x, corner.y + 30);
+             this.ctx.lineWidth = 3;
+             this.ctx.stroke();
          });
      }
  
-     async drawTitle(mode) {
+     async drawTitle(mode, titleColor) {
          const titles = {
              'story': '模式一：爽文带背',
          };
          
-         this.ctx.font = 'bold 48px "Noto Sans SC", Arial, sans-serif';
-         this.ctx.fillStyle = 'white';
-         this.ctx.textAlign = 'center';
-         this.ctx.textBaseline = 'middle';
-         
-         // 文字阴影效果
-         this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
-         this.ctx.shadowBlur = 10;
-         this.ctx.shadowOffsetX = 2;
-         this.ctx.shadowOffsetY = 2;
-         
-         this.ctx.fillText(titles[mode] || titles.story, this.width / 2, 120);
+         const title = titles[mode] || titles.story;
+         
+         // 绘制标题背景
+         const titleY = 100;
+         const titleWidth = this.ctx.measureText(title).width + 100;
+         
+         // 标题背景
+         this.ctx.fillStyle = '#fff';
+         this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
+         this.ctx.shadowBlur = 15;
+         this.ctx.shadowOffsetX = 0;
+         this.ctx.shadowOffsetY = 5;
+         this.ctx.fillRect((this.width - titleWidth) / 2, titleY - 30, titleWidth, 60);
          
          // 重置阴影
          this.ctx.shadowOffsetY = 0;
          
-         // 标题下划线
-         this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
-         this.ctx.lineWidth = 3;
+         // 绘制标题文字
+         this.ctx.font = 'bold 36px "Noto Sans SC", Arial, sans-serif';
+         this.ctx.fillStyle = titleColor;
+         this.ctx.textAlign = 'center';
+         this.ctx.textBaseline = 'middle';
+         this.ctx.fillText(title, this.width / 2, titleY);
+         
+         // 标题装饰线
+         this.ctx.strokeStyle = titleColor;
+         this.ctx.lineWidth = 2;
          this.ctx.beginPath();
-         this.ctx.moveTo(this.width / 2 - 100, 150);
-         this.ctx.lineTo(this.width / 2 + 100, 150);
+         this.ctx.moveTo((this.width / 2) - 60, titleY + 35);
+         this.ctx.lineTo((this.width / 2) + 60, titleY + 35);
          this.ctx.stroke();
      }
  
-     async drawStoryContent(story, words) {
-         const startY = 200;
-         const lineHeight = 45;
-         const maxWidth = this.width - 120;
-         
-         // 处理文本，标记高亮单词
-         const processedText = this.processTextWithHighlights(story, words);
-         
-         let currentY = startY;
-         let currentX = 60;
-         
-         this.ctx.font = '28px "Noto Sans SC", Arial, sans-serif';
+     async drawStoryContent(story, words, area) {
+         if (!story) return;
+         
+         const lineHeight = 40;
+         const maxWidth = area.width;
+         let currentY = area.y;
+         
+         // 创建内容背景
+         this.drawContentBackground(area);
+         
+         // 设置文本样式
+         this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
          this.ctx.textAlign = 'left';
          this.ctx.textBaseline = 'top';
-         
-         for (const segment of processedText) {
+         this.ctx.fillStyle = '#333';
+         
+         // 分段绘制故事内容
+         const paragraphs = story.split('\n');
+         
+         for (const paragraph of paragraphs) {
+             // 段落处理
+             if (paragraph.trim() === '') continue;
+             
+             // 先检查段落中的单词
+             const segments = this.segmentTextWithWords(paragraph, words);
+             let currentX = area.x;
+             let line = '';
+             
+             for (const segment of segments) {
+                 const words = segment.isHighlight ? [segment.text] : segment.text.split('');
+                 
+                 for (const word of words) {
+                     const wordWidth = this.ctx.measureText(word).width;
+                     
+                     if (currentX + wordWidth > area.x + maxWidth) {
+                         // 绘制当前行
+                         this.ctx.fillStyle = '#333';
+                         this.ctx.fillText(line, area.x, currentY);
+                         line = '';
+                         currentX = area.x;
+                         currentY += lineHeight;
+                         
+                         // 检查是否超出内容区域高度
+                         if (currentY > area.y + area.height - lineHeight) {
+                             // 内容太多，需要缩小字体或截断
+                             return;
+                         }
+                     }
+                     
                      if (segment.isHighlight) {
+                         // 绘制之前积累的普通文本
+                         if (line) {
+                             this.ctx.fillStyle = '#333';
+                             this.ctx.fillText(line, currentX, currentY);
+                             currentX += this.ctx.measureText(line).width;
+                             line = '';
+                         }
+                         
+                         // 绘制高亮单词
+                         const padding = 8;
+                         
+                         // 绘制高亮背景
+                         this.ctx.fillStyle = 'rgba(255, 107, 107, 0.2)';
+                         this.ctx.fillRect(currentX - padding/2, currentY - padding/2, wordWidth + padding, lineHeight - 5);
+                         
                          // 绘制高亮单词
-                 await this.drawHighlightWord(segment.text, currentX, currentY);
-                 currentX += this.ctx.measureText(segment.text).width + 40;
+                         this.ctx.fillStyle = '#d32f2f';
+                         this.ctx.font = 'bold 24px Arial, sans-serif';
+                         this.ctx.fillText(word, currentX, currentY);
+                         
+                         // 恢复默认字体
+                         this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
+                         
+                         currentX += wordWidth + padding;
                      } else {
-                 // 绘制普通文本
-                 this.ctx.fillStyle = 'rgba(255,255,255,0.95)';
-                 const words = segment.text.split('');
+                         line += word;
+                         currentX += wordWidth;
+                     }
+                 }
+             }
+             
+             // 绘制剩余的行
+             if (line) {
+                 this.ctx.fillStyle = '#333';
+                 this.ctx.fillText(line, area.x, currentY);
+             }
+             
+             currentY += lineHeight * 1.5; // 段落间距
+         }
+     }
+     
+     async drawBilingualContent(story, words, area) {
+         if (!story) return;
+         
+         // 创建内容背景
+         this.drawContentBackground(area);
+         
+         // 几乎和drawStoryContent相同，但每个单词后面加上中文释义
+         const lineHeight = 40;
+         const maxWidth = area.width;
+         let currentY = area.y;
+         
+         // 设置文本样式
+         this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
+         this.ctx.textAlign = 'left';
+         this.ctx.textBaseline = 'top';
+         this.ctx.fillStyle = '#333';
+         
+         // 分段绘制故事内容
+         const paragraphs = story.split('\n');
+         
+         for (const paragraph of paragraphs) {
+             // 段落处理
+             if (paragraph.trim() === '') continue;
+             
+             // 先检查段落中的单词
+             const segments = this.segmentTextWithWords(paragraph, words);
+             let currentX = area.x;
+             let line = '';
+             
+             for (const segment of segments) {
+                 const words = segment.isHighlight ? [segment.text] : segment.text.split('');
                  
-                 for (const char of words) {
-                     if (currentX > maxWidth) {
-                         currentX = 60;
+                 for (const word of words) {
+                     const wordWidth = this.ctx.measureText(word).width;
+                     
+                     // 如果是高亮单词，还要考虑中文解释的宽度
+                     const chineseMeaning = segment.isHighlight ? this.findChineseMeaning(segment.text, words) : '';
+                     const meaningText = chineseMeaning ? ` (${chineseMeaning})` : '';
+                     const meaningWidth = this.ctx.measureText(meaningText).width;
+                     
+                     const totalWidth = segment.isHighlight ? wordWidth + meaningWidth : wordWidth;
+                     
+                     if (currentX + totalWidth > area.x + maxWidth) {
+                         // 绘制当前行
+                         this.ctx.fillStyle = '#333';
+                         this.ctx.fillText(line, area.x, currentY);
+                         line = '';
+                         currentX = area.x;
                          currentY += lineHeight;
-                     }
-                     
-                     this.ctx.fillText(char, currentX, currentY);
-                     currentX += this.ctx.measureText(char).width;
-                 }
-             }
-             
-             if (currentX > maxWidth) {
-                 currentX = 60;
-                 currentY += lineHeight;
-             }
+                         
+                         // 检查是否超出内容区域高度
+                         if (currentY > area.y + area.height - lineHeight) {
+                             return;
+                         }
+                     }
+                     
+                     if (segment.isHighlight) {
+                         // 绘制之前积累的普通文本
+                         if (line) {
+                             this.ctx.fillStyle = '#333';
+                             this.ctx.fillText(line, currentX, currentY);
+                             currentX += this.ctx.measureText(line).width;
+                             line = '';
+                         }
+                         
+                         // 绘制高亮单词
+                         const padding = 8;
+                         
+                         // 绘制高亮背景
+                         this.ctx.fillStyle = 'rgba(66, 165, 245, 0.2)';
+                         this.ctx.fillRect(currentX - padding/2, currentY - padding/2, wordWidth + padding, lineHeight - 5);
+                         
+                         // 绘制高亮单词
+                         this.ctx.fillStyle = '#1976d2';
+                         this.ctx.font = 'bold 24px Arial, sans-serif';
+                         this.ctx.fillText(word, currentX, currentY);
+                         
+                         // 绘制中文释义
+                         this.ctx.fillStyle = '#0288d1';
+                         this.ctx.font = '22px "Noto Sans SC", Arial, sans-serif';
+                         this.ctx.fillText(meaningText, currentX + wordWidth, currentY);
+                         
+                         // 恢复默认字体
+                         this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
+                         
+                         currentX += wordWidth + meaningWidth + padding;
+                     } else {
+                         line += word;
+                         currentX += wordWidth;
+                     }
+                 }
+             }
+             
+             // 绘制剩余的行
+             if (line) {
+                 this.ctx.fillStyle = '#333';
+                 this.ctx.fillText(line, area.x, currentY);
+             }
+             
+             currentY += lineHeight * 1.5; // 段落间距
          }
      }
  
-     async drawHighlightWord(word, x, y) {
-         const padding = 12;
-         const textWidth = this.ctx.measureText(word).width;
-         const boxWidth = textWidth + padding * 2;
-         const boxHeight = 40;
+     async drawVocabList(words, area) {
+         if (!words || words.length === 0) return;
+         
+         // 创建内容背景
+         this.drawContentBackground(area);
+         
+         const lineHeight = 40;
+         const padding = 20;
+         const columnWidth = (area.width - padding) / 2;
+         let currentY = area.y + padding;
+         
+         // 绘制表头
+         this.ctx.font = 'bold 28px "Noto Sans SC", Arial, sans-serif';
+         this.ctx.textAlign = 'left';
+         this.ctx.textBaseline = 'middle';
+         this.ctx.fillStyle = '#43a047';
+         this.ctx.fillText('英文', area.x + padding, currentY);
+         
+         this.ctx.textAlign = 'left';
+         this.ctx.fillText('中文释义', area.x + padding + columnWidth, currentY);
+         
+         currentY += lineHeight + 20;
+         
+         // 绘制分隔线
+         this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
+         this.ctx.beginPath();
+         this.ctx.moveTo(area.x, currentY - 10);
+         this.ctx.lineTo(area.x + area.width, currentY - 10);
+         this.ctx.stroke();
+         
+         // 绘制单词列表
+         this.ctx.font = '24px Arial, sans-serif';
+         this.ctx.textAlign = 'left';
+         
+         words.forEach((word, index) => {
+             // 检查是否超出内容区域
+             if (currentY > area.y + area.height - lineHeight) {
+                 return;
+             }
+             
+             // 绘制单词
+             this.ctx.fillStyle = '#333';
+             this.ctx.font = 'bold 24px Arial, sans-serif';
+             this.ctx.fillText(word.en, area.x + padding, currentY);
              
-         // 绘制高亮背景
-         const gradient = this.ctx.createLinearGradient(x, y, x + boxWidth, y + boxHeight);
-         gradient.addColorStop(0, 'rgba(255,255,255,0.3)');
-         gradient.addColorStop(1, 'rgba(255,255,255,0.1)');
-         
-         this.ctx.fillStyle = gradient;
-         this.ctx.fillRect(x, y - 5, boxWidth, boxHeight);
-         
-         // 绘制边框
-         this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
-         this.ctx.lineWidth = 2;
-         this.ctx.strokeRect(x, y - 5, boxWidth, boxHeight);
-         
-         // 绘制文字
-         this.ctx.fillStyle = 'white';
-         this.ctx.font = 'bold 28px Arial, sans-serif';
-         this.ctx.fillText(word, x + padding, y);
-     }
- 
-     processTextWithHighlights(story, words) {
+             // 绘制中文释义
+             this.ctx.fillStyle = '#555';
+             this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
+             
+             // 如果释义太长，进行截断
+             let meaning = word.cn || '';
+             const maxMeaningWidth = columnWidth - padding * 2;
+             
+             if (this.ctx.measureText(meaning).width > maxMeaningWidth) {
+                 // 截断释义
+                 let truncated = '';
+                 for (let i = 0; i < meaning.length; i++) {
+                     const testText = truncated + meaning[i];
+                     if (this.ctx.measureText(testText).width > maxMeaningWidth) {
+                         truncated += '...';
+                         break;
+                     }
+                     truncated += meaning[i];
+                 }
+                 meaning = truncated;
+             }
+             
+             this.ctx.fillText(meaning, area.x + padding + columnWidth, currentY);
+             
+             // 绘制分隔线
+             if (index < words.length - 1) {
+                 this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
+                 this.ctx.beginPath();
+                 this.ctx.moveTo(area.x + padding, currentY + lineHeight / 2);
+                 this.ctx.lineTo(area.x + area.width - padding, currentY + lineHeight / 2);
+                 this.ctx.stroke();
+             }
+             
+             currentY += lineHeight;
+         });
+     }
+ 
+     async drawTestContent(story, words, area) {
+         if (!story) return;
+         
+         // 创建内容背景
+         this.drawContentBackground(area);
+         
+         const lineHeight = 40;
+         const maxWidth = area.width;
+         let currentY = area.y;
+         
+         // 设置文本样式
+         this.ctx.font = '24px "Noto Sans SC", Arial, sans-serif';
+         this.ctx.textAlign = 'left';
+         this.ctx.textBaseline = 'top';
+         this.ctx.fillStyle = '#333';
+         
+         // 分段绘制故事内容
+         const paragraphs = story.split('\n');
+         
+         for (const paragraph of paragraphs) {
+             // 段落处理
+             if (paragraph.trim() === '') continue;
+             
+             // 先检查段落中的单词 - 在测试模式下，单词将被下划线替代
+             const segments = this.segmentTextWithWords(paragraph, words);
+             let currentX = area.x;
+             let line = '';
+             
+             for (const segment of segments) {
+                 const words = segment.isHighlight ? [segment.text] : segment.text.split('');
+                 
+                 for (const word of words) {
+                     if (segment.isHighlight) {
+                         // 绘制之前积累的普通文本
+                         if (line) {
+                             this.ctx.fillStyle = '#333';
+                             this.ctx.fillText(line, currentX, currentY);
+                             currentX += this.ctx.measureText(line).width;
+                             line = '';
+                         }
+                         
+                         // 绘制填空线
+                         const blankWidth = Math.max(this.ctx.measureText(word).width, 80);
+                         
+                         // 检查是否需要换行
+                         if (currentX + blankWidth > area.x + maxWidth) {
+                             currentY += lineHeight;
+                             currentX = area.x;
+                             
+                             // 检查是否超出内容区域高度
+                             if (currentY > area.y + area.height - lineHeight) {
+                                 return;
+                             }
+                         }
+                         
+                         // 绘制下划线
+                         this.ctx.strokeStyle = '#333';
+                         this.ctx.lineWidth = 1;
+                         this.ctx.beginPath();
+                         this.ctx.moveTo(currentX, currentY + lineHeight - 10);
+                         this.ctx.lineTo(currentX + blankWidth, currentY + lineHeight - 10);
+                         this.ctx.stroke();
+                         
+                         currentX += blankWidth + 10;
+                     } else {
+                         const wordWidth = this.ctx.measureText(word).width;
+                         
+                         if (currentX + wordWidth > area.x + maxWidth) {
+                             // 绘制当前行
+                             this.ctx.fillStyle = '#333';
+                             this.ctx.fillText(line, area.x, currentY);
+                             line = '';
+                             currentX = area.x;
+                             currentY += lineHeight;
+                             
+                             // 检查是否超出内容区域高度
+                             if (currentY > area.y + area.height - lineHeight) {
+                                 return;
+                             }
+                         }
+                         
+                         line += word;
+                         currentX += wordWidth;
+                     }
+                 }
+             }
+             
+             // 绘制剩余的行
+             if (line) {
+                 this.ctx.fillStyle = '#333';
+                 this.ctx.fillText(line, area.x, currentY);
+             }
+             
+             currentY += lineHeight * 1.5; // 段落间距
+         }
+         
+         // 在测试页面底部添加提示
+         const bottomY = area.y + area.height - 50;
+         this.ctx.font = 'italic 18px Arial, sans-serif';
+         this.ctx.fillStyle = '#666';
+         this.ctx.textAlign = 'center';
+         this.ctx.fillText('提示：空白处填入相应的英语单词', this.width / 2, bottomY);
+     }
+ 
+     drawContentBackground(area) {
+         // 绘制内容区域背景
+         this.ctx.fillStyle = '#fff';
+         this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
+         this.ctx.shadowBlur = 15;
+         this.ctx.shadowOffsetX = 0;
+         this.ctx.shadowOffsetY = 5;
+         this.ctx.fillRect(area.x - 20, area.y - 20, area.width + 40, area.height + 40);
+         
+         // 重置阴影
+         this.ctx.shadowColor = 'transparent';
+         this.ctx.shadowBlur = 0;
+         this.ctx.shadowOffsetX = 0;
+         this.ctx.shadowOffsetY = 0;
+     }
+ 
+     drawFooter() {
+         // 绘制页脚
+         const footerText = '爽文带背单词卡片生成器';
+         const footerY = this.height - 60;
+         
+         this.ctx.font = '18px "Noto Sans SC", Arial, sans-serif';
+         this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
+         this.ctx.textAlign = 'center';
+         this.ctx.textBaseline = 'middle';
+         this.ctx.fillText(footerText, this.width / 2, footerY);
+         
+         // 添加日期
+         const date = new Date().toLocaleDateString('zh-CN', {
+             year: 'numeric',
+             month: 'long',
+             day: 'numeric'
+         });
+         
+         this.ctx.font = '16px Arial, sans-serif';
+         this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
+         this.ctx.fillText(date, this.width / 2, footerY + 25);
+     }
+ 
+     segmentTextWithWords(text, words) {
+         if (!words || words.length === 0) {
+             return [{text, isHighlight: false}];
+         }
+         
          const segments = [];
-         let remaining = story;
+         let remaining = text;
          
          words.forEach(wordObj => {
              const word = wordObj.en;
-             const regex = new RegExp(`\\b(${word})\\b`, 'gi');
+             if (!word) return;
+             
+             // 使用正则表达式，但注意可能的特殊字符
+             const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+             const regex = new RegExp(`(${escapedWord})`, 'gi');
              const parts = remaining.split(regex);
+             
+             remaining = '';
              
              for (let i = 0; i < parts.length; i++) {
-                 if (i % 2 === 0) {
-                     if (parts[i]) segments.push({text: parts[i], isHighlight: false});
-                 } else {
+                 if (parts[i].toLowerCase() === word.toLowerCase()) {
+                     if (remaining) {
+                         segments.push({text: remaining, isHighlight: false});
+                         remaining = '';
+                     }
                      segments.push({text: parts[i], isHighlight: true});
+                 } else {
+                     remaining += parts[i];
                  }
              }
          });
          
-         return segments.filter(s => s.text);
+         if (remaining) {
+             segments.push({text: remaining, isHighlight: false});
+         }
+         
+         return segments;
+     }
+ 
+     findChineseMeaning(englishWord, words) {
+         for (const wordObj of words) {
+             if (wordObj.en && wordObj.en.toLowerCase() === englishWord.toLowerCase()) {
+                 return wordObj.cn || '';
+             }
+         }
+         return '';
      }
  
  }
  
- // 使用示例
+ // 全局实例
  window.canvasRenderer = new CanvasCardRenderer();
```

---

Now that we've updated the CanvasCardRenderer, let's update the main.js file to use our renderer correctly:

---

Read file: public/js/main.js

---

The downloadCard function in main.js is already updated correctly! Let's test our implementation:

---

```bash
cd englishs_xx && node server.js
```

---

Let's create a small test HTML file to verify our canvas renderer is working correctly:

---

```diff
- 
+ <!DOCTYPE html>
+ <html lang="zh-CN">
+ <head>
+     <meta charset="UTF-8">
+     <meta name="viewport" content="width=device-width, initial-scale=1.0">
+     <title>Canvas 渲染器测试</title>
+     <script src="js/canvas-renderer.js"></script>
+     <style>
+         body {
+             font-family: 'Arial', sans-serif;
+             margin: 0;
+             padding: 20px;
+             background-color: #f5f5f5;
+         }
+         .container {
+             max-width: 1200px;
+             margin: 0 auto;
+             background-color: white;
+             padding: 20px;
+             border-radius: 8px;
+             box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
+         }
+         h1 {
+             color: #333;
+             text-align: center;
+             margin-bottom: 30px;
+         }
+         .controls {
+             display: flex;
+             gap: 20px;
+             margin-bottom: 20px;
+         }
+         button {
+             background-color: #4CAF50;
+             border: none;
+             color: white;
+             padding: 10px 20px;
+             text-align: center;
+             text-decoration: none;
+             display: inline-block;
+             font-size: 16px;
+             margin: 4px 2px;
+             cursor: pointer;
+             border-radius: 4px;
+         }
+         .preview {
+             margin-top: 20px;
+             text-align: center;
+         }
+         img {
+             max-width: 100%;
+             height: auto;
+             border: 1px solid #ddd;
+         }
+     </style>
+ </head>
+ <body>
+     <div class="container">
+         <h1>Canvas 卡片渲染器测试</h1>
+         
+         <div class="controls">
+             <button onclick="testStoryMode()">测试爽文带背</button>
+             <button onclick="testBilingualMode()">测试中英对照</button>
+             <button onclick="testVocabMode()">测试单词列表</button>
+             <button onclick="testTestMode()">测试填空测试</button>
+         </div>
+         
+         <div class="preview">
+             <h2>预览区域</h2>
+             <img id="preview" src="" alt="渲染结果将显示在这里">
+         </div>
+     </div>
+ 
+     <script>
+         // 测试数据
+         const testStory = `小李的牙齿痛得厉害，只好硬着头皮去看 dentist。诊所里挂着 Santa Claus 的画像，旁边还摆着一块发霉的 blue 面包。"这 bread 是艺术品，"医生笑着解释，" however，你得先躺下。"突然，门外传来轰鸣声，一辆 van 冲进诊所！车上跳下一只穿西装的 penguin，大喊："快逃！欧洲 Europe 来的马戏团着火了！"三人爬上 jungle gym 躲避，只见火焰吞没了整个 stadium。火势渐熄后，penguin 摘下领结叹气："其实我是来补牙的..."原来全是止痛药的幻觉！`;
+         
+         const testWords = [
+             { en: "dentist", cn: "牙医" },
+             { en: "Santa Claus", cn: "圣诞老人" },
+             { en: "blue", cn: "蓝色" },
+             { en: "bread", cn: "面包" },
+             { en: "however", cn: "然而" },
+             { en: "van", cn: "货车" },
+             { en: "penguin", cn: "企鹅" },
+             { en: "Europe", cn: "欧洲" },
+             { en: "jungle gym", cn: "攀登架" },
+             { en: "stadium", cn: "体育馆" }
+         ];
+         
+         // 测试函数
+         async function testStoryMode() {
+             const preview = document.getElementById('preview');
+             const imageUrl = await window.canvasRenderer.renderStoryCard(testStory, testWords, 'story');
+             preview.src = imageUrl;
+         }
+         
+         async function testBilingualMode() {
+             const preview = document.getElementById('preview');
+             const imageUrl = await window.canvasRenderer.renderStoryCard(testStory, testWords, 'bilingual');
+             preview.src = imageUrl;
+         }
+         
+         async function testVocabMode() {
+             const preview = document.getElementById('preview');
+             const imageUrl = await window.canvasRenderer.renderStoryCard('', testWords, 'vocab');
+             preview.src = imageUrl;
+         }
+         
+         async function testTestMode() {
+             const preview = document.getElementById('preview');
+             const imageUrl = await window.canvasRenderer.renderStoryCard(testStory, testWords, 'test');
+             preview.src = imageUrl;
+         }
+     </script>
+ </body>
+ </html> 
```

---

I've now:

1. Added the Canvas renderer script to the main index.html
2. Updated the download buttons in index.html to pass the correct mode parameter
3. Created a comprehensive CanvasCardRenderer.js implementation with:
   - Beautiful themed backgrounds for each card type
   - Proper text wrapping and layout
   - High-quality rendering for all four card types (爽文带背, 中英对照, 单词列表, 填空测试)
   - Decorative elements and professional styling
4. Created a test page (test-canvas.html) to verify the renderer works correctly

Our implementation should now produce high-quality downloadable images for all card types with proper layout and design. The Canvas approach directly creates images without relying on HTML-to-image conversion, which should resolve the quality issues you were experiencing.

You can test the implementation by:

1. Opening the main app at http://localhost:3000
2. Generating cards and clicking the download button
3. Or testing individual rendering modes with the test page at http://localhost:3000/test-canvas.html

The key advantages of this implementation:

1. Direct Canvas rendering for highest quality output
2. Proper text wrapping and layout control
3. Beautiful themed designs for different card types
4. Optimized for Chinese and English text
5. Complete control over visual elements

Let me know if you need any adjustments to the implementation!

---

_**User**_

生成出来的文字没有处理好！，而且文字有折叠！，填空的空不见了，请修复，你可以在网络上搜索看看有没有这种把网页变成图片的处理方案，参考看看！

---

_**Assistant**_



---

I'll fix the text rendering issues in our Canvas implementation. The main problems appear to be text wrapping/folding and the missing blanks in the test mode.

---

<details>
            <summary>Searched web "canvas text wrapping multilingual text rendering chinese english" • **4** results</summary>
        
| Title | URL |
|-------|-----|
| 文本对齐与度量 · CANVAS——Draw on the Web | https://airingursb.gitbooks.io/canvas/content/18.html |
| Anton's Research Ramblings - 2018_07_11_rendering_arabic_text | https://antongerdelan.net/blog/formatted/2018_07_11_rendering_arabic_text.html |
| GitHub - nhelfman/canvas-formatted-text | https://github.com/nhelfman/canvas-formatted-text |
| HTML5 - Wrap Text in Canvas | https://miteshmaheta.blogspot.com/search/label/Wrap%20Text |

</details>

---

Now I'll update our canvas-renderer.js implementation to address the text rendering issues:

---

Cancelled

---



---

_**User**_

请继续！

---

_**Assistant**_



---



---

