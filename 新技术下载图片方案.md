专业版图片/PDF生成器 - 项目集成技术文档

你好！本篇文档旨在帮助你将我们最新构建的、基于 Node.js + Puppeteer 的服务器端渲染方案，作为一个独立的功能模块，平滑地集成到你现有的项目中。一、核心架构与工作流程在集成之前，请务必理解本方案的核心工作模式：前端 (Client): 负责提供用户界面 (UI)。用户在你的项目页面上选择生成模式（如“中英对照”）、输出格式（如“A4”）和字体大小等参数。后端 (Server): 你的项目后端需要新增一个专门的API接口（例如 /api/generate-card）。数据流:前端UI收集用户的选项和需要展示的数据（如单词列表、故事文本）。前端通过 fetch 请求，将这些数据以 JSON 格式 POST 到后端的 /api/generate-card 接口。后端接口接收到请求，调用 Puppeteer 模块。Puppeteer 在服务器上启动一个无头（Headless）Chrome浏览器，加载一个包含样式和数据的HTML模板。Puppeteer 利用Chrome强大的渲染引擎，生成像素完美的PNG图片或标准PDF。服务器将生成的图片或PDF文件流返回给前端。前端接收到文件流，触发浏览器进行下载或在页面上进行预览。这种架构将复杂的排版和渲染任务从用户浏览器中剥离，交由服务器处理，从而保证了稳定性、高质量和强大的功能。二、环境准备请确保你的项目后端服务器环境满足以下条件：Node.js: 版本建议 v16.x 或更高。npm 或 yarn: 用于安装依赖包。在你的项目后端根目录下，打开终端，安装核心依赖：# 安装 Express 用于快速搭建API接口 (如果你的项目已使用其他框架如Koa，则无需安装)
npm install express

# 安装 Puppeteer，这是我们的核心渲染引擎
npm install puppeteer
注意: puppeteer 在安装时会下载一个适配当前系统的Chromium浏览器（约几百MB），请确保网络连接通畅。三、后端集成步骤你需要将 V5 方案中的服务器逻辑，作为一个新的API路由添加到你的项目中。1. 创建生成模块 (generator.js)建议将生成逻辑封装成一个独立的模块。在你的后端代码目录（例如 routes/ 或 services/）下创建一个新文件 cardGenerator.js：// file: services/cardGenerator.js

const puppeteer = require('puppeteer');

/**
 * 根据HTML内容和选项生成图片或PDF
 * @param {string} htmlContent - 用于渲染的完整HTML字符串
 * @param {object} options - 生成选项，如尺寸、格式等
 * @returns {Buffer} - 返回图片或PDF的文件缓冲区
 */
async function generateOutput(htmlContent, options) {
    // 启动 Puppeteer
    const browser = await puppeteer.launch({ 
        headless: true,
        // 在某些Linux服务器上可能需要此参数
        args: ['--no-sandbox', '--disable-setuid-sandbox'] 
    });
    const page = await browser.newPage();

    try {
        // 设置页面内容
        await page.setContent(htmlContent, { waitUntil: 'networkidle0' });

        let outputBuffer;

        if (options.output === 'pdf') {
            // --- 生成 PDF ---
            outputBuffer = await page.pdf({
                format: options.format, // e.g., 'A4'
                printBackground: true,
                margin: { top: '2cm', right: '1cm', bottom: '2cm', left: '1cm' }
            });
        } else {
            // --- 生成图片 ---
            await page.setViewport({
                width: options.width,
                height: options.height,
                deviceScaleFactor: 2 // 2倍分辨率保证高清
            });
            outputBuffer = await page.screenshot({
                type: 'png',
                fullPage: true
            });
        }

        return outputBuffer;

    } catch (error) {
        console.error('Puppeteer generation failed:', error);
        throw new Error('Failed to generate output with Puppeteer.');
    } finally {
        // 确保浏览器被关闭
        await browser.close();
    }
}

module.exports = { generateOutput };
2. 在主服务中创建API接口现在，在你项目的主服务器文件（例如 server.js 或 app.js）中，引入刚才创建的模块并设置一个新的API路由。// file: server.js (或你的主后端文件)

const express = require('express');
const { generateOutput } = require('./services/cardGenerator'); // 引入模块

const app = express();
app.use(express.json({ limit: '10mb' })); // 允许接收较大的JSON数据

// ... 你项目已有的其他路由和中间件 ...

// --- 新增的卡片生成API路由 ---
app.post('/api/generate-card', async (req, res) => {
    console.log('Received request for /api/generate-card');
    const { htmlContent, options } = req.body;

    if (!htmlContent || !options) {
        return res.status(400).json({ error: 'Missing required parameters: htmlContent or options' });
    }

    try {
        const buffer = await generateOutput(htmlContent, options);

        if (options.output === 'pdf') {
            res.contentType('application/pdf');
        } else {
            res.contentType('image/png');
        }
        res.send(buffer);
        console.log('Successfully sent generated output.');

    } catch (error) {
        console.error('API Error:', error.message);
        res.status(500).json({ error: 'An error occurred during file generation.' });
    }
});


const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
四、前端集成步骤前端部分主要负责 UI交互 和 API调用。你需要将V5方案中的HTML和JS逻辑，适配到你项目的页面中。1. 添加UI控件在你需要提供此功能的页面上，添加相应的HTML控件：<!-- 这是你项目页面中的一部分 -->
<div class="card-generator-controls">
    <h3>生成选项</h3>
    
    <div class="control-group">
        <label for="mode-select">选择模式:</label>
        <select id="mode-select">
            <option value="story-highlight">爽文带背</option>
            <option value="story-cn">中英对照</option>
            <option value="vocab-list">单词列表</option>
        </select>
    </div>

    <div class="control-group">
        <label for="format-select">选择尺寸:</label>
        <select id="format-select">
            <option value="social_3_4">自媒体 (3:4)</option>
            <option value="A4_portrait">A4打印 (纵向)</option>
        </select>
    </div>

    <div class="control-group">
        <label for="font-size-input">正文字号 (px):</label>
        <input type="number" id="font-size-input" value="20" min="10" max="40">
    </div>

    <button id="generate-btn">开始生成</button>
    <div id="status-message"></div>
</div>

<div id="preview-container" style="display:none;">
    <h4>生成结果预览</h4>
    <img id="preview-img" src="" alt="生成结果预览" />
    <a id="download-btn" href="#" download>下载</a>
</div>
2. 编写前端调用脚本在你的前端JS文件中，添加事件监听和API调用逻辑。// file: public/js/your-project-script.js

document.addEventListener('DOMContentLoaded', () => {
    const generateBtn = document.getElementById('generate-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', handleGenerateClick);
    }
});

async function handleGenerateClick() {
    const statusEl = document.getElementById('status-message');
    const previewContainer = document.getElementById('preview-container');
    const previewImg = document.getElementById('preview-img');
    const downloadBtn = document.getElementById('download-btn');

    // --- 1. UI反馈：进入加载状态 ---
    generateBtn.disabled = true;
    statusEl.textContent = '正在向服务器发送请求...';
    previewContainer.style.display = 'none';

    // --- 2. 收集数据和选项 ---
    const mode = document.getElementById('mode-select').value;
    const format = document.getElementById('format-select').value;
    const fontSize = document.getElementById('font-size-input').value;
    
    // **重要**: 这里的 `dayData` 应该从你的项目状态或API中获取
    const dayData = { /* ... 你的单词和故事数据 ... */ }; 
    
    const { htmlContent, options } = preparePayloadForBackend(dayData, mode, format, fontSize);

    try {
        // --- 3. 调用后端API ---
        const response = await fetch('/api/generate-card', { // 注意这里的API路径
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ htmlContent, options })
        });

        if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || `服务器错误: ${response.status}`);
        }
        
        statusEl.textContent = '收到响应，正在处理文件...';

        // --- 4. 处理返回的文件流 ---
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        
        if (options.output === 'pdf') {
            downloadBtn.href = url;
            downloadBtn.download = `${options.filename}.pdf`;
            downloadBtn.click(); // 直接触发下载
            statusEl.textContent = 'PDF 已成功下载！';
        } else {
            previewImg.src = url;
            downloadBtn.href = url;
            downloadBtn.download = `${options.filename}.png`;
            previewContainer.style.display = 'block';
            statusEl.textContent = '图片生成成功！';
        }

    } catch (error) {
        console.error('生成失败:', error);
        statusEl.textContent = `生成失败: ${error.message}`;
    } finally {
        generateBtn.disabled = false;
    }
}

/**
 * 准备发送到后端的数据包
 * @param {object} dayData - 包含单词和故事的数据
 * @param {string} mode - 'story-highlight', 'vocab-list', etc.
 * @param {string} format - 'social_3_4' or 'A4_portrait'
 * @param {string} fontSize - e.g., '20'
 * @returns {object} - { htmlContent, options }
 */
function preparePayloadForBackend(dayData, mode, format, fontSize) {
    // 这个函数从 V5 方案的前端JS中复制过来，用于生成HTML模板字符串
    // generateCardHtml(...) 和 getFullHtmlTemplate(...)
    // ... (此处省略这两个函数的具体实现，请从V5方案中复制)
    const { title, bodyHtml, filenamePrefix } = generateCardHtml(dayData, mode);
    const htmlContent = getFullHtmlTemplate(title, bodyHtml, fontSize);
    let options = {};

    if (format === 'A4_portrait') {
        options = { output: 'pdf', format: 'A4', filename: filenamePrefix };
    } else {
        options = { output: 'png', width: 1200, height: 1600, filename: filenamePrefix };
    }
    return { htmlContent, options };
}

// --- 你需要从V5方案中复制以下两个辅助函数到这里 ---
// function generateCardHtml(dayData, mode) { ... }
// function getFullHtmlTemplate(title, bodyHtml, fontSize) { ... }

五、总结与要点解耦: 此方案的核心是前后端解耦。前端负责“问”，后端负责“答”。这种模式清晰、稳定且易于维护。数据源: 在 handleGenerateClick 函数中，dayData 对象被写为静态数据。在你的实际项目中，你需要修改这部分，使其能动态地从你的数据库、状态管理器（如Redux/Vuex）或另一个API获取当前的单词数据。模板函数: generateCardHtml 和 getFullHtmlTemplate 这两个函数是“模板引擎”，负责将数据渲染成HTML字符串。它们是纯函数，不依赖任何外部状态，你可以把它们放在一个独立的 template.js 工具文件中，方便管理。安全: 由于前端可以将任意HTML内容发送到后端由Puppeteer渲染，如果这是一个对公网开放的服务，需要警惕XSS等注入攻击。在当前内部使用的场景下，风险较低。遵循以上步骤，你就可以成功地将这个专业、强大的图片和PDF生成功能，作为一项服务集成到你的项目中了。